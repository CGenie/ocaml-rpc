<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Common (ppx_deriving_rpc.Common)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ppx_deriving_rpc</a> &#x00BB; Common</nav><h1>Module <code>Common</code></h1></header><dl><dt class="spec value" id="val-core_types"><a href="#val-core_types" class="anchor"></a><code><span class="keyword">val </span>core_types : Ppxlib.location <span>&#45;&gt;</span> (string<span class="keyword"> * </span>Ppxlib.expression) Base.List.t</code></dt></dl><aside><p>Many of the following functions are lifted from ppx_deriving. It's quite likely that there are good alternatives to these somewhere in ppxlib, but I've not yet found them.</p><p>They are used to deal with parameterised types. When declaring a function derived from a parameterised type, the function will be extended to take an argument for each type parameter. The important functions below are `poly_fun_of_type_decl` and `poly_apply_of_type_decl` - for declaring and using the derived functions respectively.</p></aside><dl><dt class="spec value" id="val-fold_right_type_params"><a href="#val-fold_right_type_params" class="anchor"></a><code><span class="keyword">val </span>fold_right_type_params : (string <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> (Ppxlib.core_type<span class="keyword"> * </span><span class="type-var">'b</span>) Base.List.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_right_type_decl"><a href="#val-fold_right_type_decl" class="anchor"></a><code><span class="keyword">val </span>fold_right_type_decl : (string <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_right_type_decl fn accum type_</code> performs a right fold over all type variable (i.e. not wildcard) parameters in <code>type_</code>.</p></dd></dl><dl><dt class="spec value" id="val-poly_fun_of_type_decl"><a href="#val-poly_fun_of_type_decl" class="anchor"></a><code><span class="keyword">val </span>poly_fun_of_type_decl : loc:Ppxlib__.Import.location <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> Ppxlib__.Import.expression <span>&#45;&gt;</span> Ppxlib__.Import.expression</code></dt><dd><p><code>poly_fun_of_type_decl type_ expr</code> wraps <code>expr</code> into <code>fun poly_N -&gt; ...</code> for every type parameter <code>'N</code> present in <code>type_</code>. For example, if <code>type_</code> refers to <code>type ('a, 'b) map</code>, <code>expr</code> will be wrapped into <code>fun poly_a poly_b -&gt; [%e expr]</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_left_type_params"><a href="#val-fold_left_type_params" class="anchor"></a><code><span class="keyword">val </span>fold_left_type_params : (<span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (Ppxlib.core_type<span class="keyword"> * </span><span class="type-var">'b</span>) Base.List.t <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_left_type_decl"><a href="#val-fold_left_type_decl" class="anchor"></a><code><span class="keyword">val </span>fold_left_type_decl : (<span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_left_type_decl fn accum type_</code> performs a left fold over all type variable (i.e. not wildcard) parameters in <code>type_</code>.</p></dd></dl><dl><dt class="spec value" id="val-poly_apply_of_type_decl"><a href="#val-poly_apply_of_type_decl" class="anchor"></a><code><span class="keyword">val </span>poly_apply_of_type_decl : loc:Ppxlib__.Location.t <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> Ppxlib_ast__.Import.Parsetree.expression <span>&#45;&gt;</span> Ppxlib_ast__.Import.Parsetree.expression</code></dt><dd><p><code>poly_apply_of_type_decl type_ expr</code> wraps <code>expr</code> into <code>expr poly_N</code> for every type parameter <code>'N</code> present in <code>type_</code>. For example, if <code>type_</code> refers to <code>type ('a, 'b) map</code>, <code>expr</code> will be wrapped into <code>[%e expr] poly_a poly_b</code>. <code>_</code> parameters are ignored.</p></dd></dl><dl><dt class="spec value" id="val-expr_of_option"><a href="#val-expr_of_option" class="anchor"></a><code><span class="keyword">val </span>expr_of_option : loc:Ppxlib.location <span>&#45;&gt;</span> Ppxlib.expression option <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>expr_of_option ~loc o</code> turns an optional expression into an expression of an optional value. In several places there are optional attributes, e.g. <code>@@version foo</code>, which end up as values of type `expression option`. These are often turned into optional values in the generated code.</p></dd></dl><dl><dt class="spec module" id="module-Attrs"><a href="#module-Attrs" class="anchor"></a><code><span class="keyword">module </span><a href="Attrs/index.html">Attrs</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Typed attribute getters</p></dd></dl><dl><dt class="spec value" id="val-attr"><a href="#val-attr" class="anchor"></a><code><span class="keyword">val </span>attr : Ppxlib__.Location.t <span>&#45;&gt;</span> Base.String.t <span>&#45;&gt;</span> (Base.String.t Ppxlib.loc<span class="keyword"> * </span>Ppxlib__.Import.payload) Base.List.t <span>&#45;&gt;</span> string Base.Option.t</code></dt><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val </span>split : Base.String.t <span>&#45;&gt;</span> Base.String.t list</code></dt><dt class="spec value" id="val-convert_doc"><a href="#val-convert_doc" class="anchor"></a><code><span class="keyword">val </span>convert_doc : Base.String.t <span>&#45;&gt;</span> Base.String.t Base.List.t</code></dt><dt class="spec value" id="val-get_doc"><a href="#val-get_doc" class="anchor"></a><code><span class="keyword">val </span>get_doc : loc:Ppxlib__.Location.t <span>&#45;&gt;</span> Ppxlib__.Import.expression option <span>&#45;&gt;</span> Ppxlib.attributes <span>&#45;&gt;</span> Ppxlib__.Import.expression</code></dt></dl></div></body></html>